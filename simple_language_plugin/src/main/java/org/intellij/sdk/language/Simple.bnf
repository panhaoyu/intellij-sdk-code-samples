// Copyright 2000-2022 JetBrains s.r.o. and other contributors. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.
{
  parserClass="org.intellij.sdk.language.parser.SimpleParser"
  parserUtilClass="org.intellij.sdk.language.parser.SimpleParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Simple"
  psiImplClassSuffix="Impl"
  psiPackage="org.intellij.sdk.language.psi"
  psiImplPackage="org.intellij.sdk.language.psi.impl"

  elementTypeHolderClass="org.intellij.sdk.language.psi.SimpleTypes"
  elementTypeClass="org.intellij.sdk.language.psi.SimpleElementType"
  tokenTypeClass="org.intellij.sdk.language.psi.SimpleTokenType"

  psiImplUtilClass="org.intellij.sdk.language.psi.impl.SimplePsiImplUtil"

  tokens = [
    space="regexp: +"
//    NEWLINE='regexp:(\R( \t)*)'
//
//    FISH="fish"
//    DEFINE="define"
//    END="end"
//    CASEOF="caseof"
//    CASE="case"
//    ENDCASE="endcase"
//    COMMAND="command"
//    ENDCOMMAND="endcommand"
//    EXIT="exit"
//    ELLIPSIS="..."
//    GLOBAL="global"
//    LOCAL="local"
//    IF="if"
//    THEN="then"
//    ELSEIF="else if"
//    ELSE="else"
//    ENDIF="endif"
//    LOCK="lock"
//    LOOP="loop"
//    FOREACH="foreach"
//    ENDLOOP="endloop"
//    CONTINUE="continue"
//    BREAK="break"
//    WHILE="while"
//    FOR="for"
//    RETURN="return"
//    SECTION="section"
//    ENDSECTION="endsection"
//    STRUCT="struct"
//    ARRAY="[Aa]rray"
//
//    STRING_LITERAL="\".*?\""
//    NUMBER_LITERAL="[0-9][0-9*](\.[0-9])?"
//    COMMENT=";.*?"
//    ASSIGNMENT_OPERATOR="="
//    FUNCTION_CALL_OPERATOR="@"
//    COMMA_OPERATOR=","
//    DOT_OPERATOR="."
//    LEFT_PARENTHESIS="("
//    RIGHT_PARENTHESIS=")"
//    LEFT_SQUARE_BRACKET="["
//    RIGHT_SQUARE_BRACKET="]"
//    LEFT_CURLY_BRACKET="{"
//    RIGHT_CURLY_BRACKET="}"
//
//    identifier="regexp:[a-zA-Z_][a-zA-Z0-9_]*"
  ]
}

simpleFile ::= eol* command_scope (eol command_scope)* eol*

command_scope ::= (
    command_scope_inline_fish_statement |
    function_define |
    command_scope_function_call |
    command_line
)
command_scope_inline_fish_statement ::= command_scope_inline_fish_expression

function_define ::= function_define_header (eol fish_block)? eol end
private function_define_header ::= fish? define identifier_element function_parameter_list?
private function_parameter_list ::= (left_parenthesis identifier_element (comma_operator identifier_element)* right_parenthesis)

fish_block ::=  single_fish_block (eol single_fish_block)*
private single_fish_block ::= if_block | loop_block | case_block | command_block | fish_statement

if_block ::= if expression then?
             (eol fish_block)?
             (eol else_if_block)*
             (eol else_block)?
             eol endif
else_if_block ::= elseif expression then? (eol fish_block)?
else_block ::=  else (eol fish_block)?

loop_block ::= loop_header (eol fish_block)? eol endloop
private loop_header ::= loop (loop_each | loop_indexed | loop_for | loop_while)
private loop_indexed ::= assignment_left_loop loop_indexed_range
private loop_indexed_range ::=
    left_parenthesis expression comma_operator
    expression (comma_operator expression)? right_parenthesis
private loop_while ::= while expression
private loop_each ::= foreach assignment_left_loop expression
private loop_for ::= for left_parenthesis local? expression comma_operator expression comma_operator expression right_parenthesis


case_block ::= case_of expression (eol fish_block)? (eol case_clause)* eol end_case
private case_clause ::= case expression (eol fish_block)?

command_block ::= command (eol command_body)? eol end_command
private command_body ::= command_line (eol command_line)*
private command_line ::= any_in_command+
private any_in_command ::= (
    identifier_element | left_square_bracket | right_square_bracket | left_parenthesis | right_parenthesis | comma_operator |
    assignment_operator|
    unary_operator | binary_operator| dot_operator|at_operator | literal | ellipsis | keywords_in_command_block
 )
private keywords_in_command_block ::= (fish | case_of | case | end_case | define | end | exit | global | if | then |
    elseif | else | endif | local | lock | loop | endloop | continue | return | section | end_section | struct )

fish_statement ::= (
    array_declare_statement |
    assignment_statement |
    expression |
    break |
    continue |
    exit
    )

function_call_statement ::= function_call_expression
private command_scope_function_call ::= at_operator identifier_element parenthesis_csv_expression


assignment_statement ::= (local | global)? assignment_expression (comma_operator assignment_expression)*
private array_declare_statement ::= array identifier_element left_parenthesis number_literal right_parenthesis
private assignment_expression ::= assignment_target assignment_right?
private assignment_target ::= identifier_element parenthesis_csv_expression?
private assignment_right ::= assignment_operator expression
private assignment_left_loop ::= local? identifier_element


private expression ::= (left_square_bracket binary_expression right_square_bracket) |  binary_expression
private parenthesis_expression ::= left_parenthesis expression right_parenthesis
private function_call_expression ::= identifier_element parenthesis_csv_expression
private csv_expression ::= expression (comma_operator expression)*
private parenthesis_csv_expression ::= left_parenthesis csv_expression right_parenthesis
private command_scope_inline_fish_expression ::= left_square_bracket fish_statement right_square_bracket

private binary_expression ::= non_binary_expression (binary_operator non_binary_expression)*
private non_binary_expression ::=  parenthesis_expression | function_call_expression | unary_expression | value
private unary_expression ::= unary_operator expression

////词汇之间的组合
value ::= identifier_element | literal
literal ::= string_literal | number_literal



property ::= (identifier_element) {
//  pin=3
  recoverWhile="recover_property"
  mixin="org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl"
  implements="org.intellij.sdk.language.psi.SimpleNamedElement"
  methods=[getName setName getNameIdentifier getPresentation]
}
private recover_property ::= !(identifier_element)


identifier_element ::= IDENTIFIER {
////  pin=3
//  recoverWhile="recover_property"
  mixin="org.intellij.sdk.language.psi.impl.SimpleNamedElementImpl"
  implements="org.intellij.sdk.language.psi.SimpleNamedElement"
  methods=[getName setName getNameIdentifier getPresentation getReference getReferences getTextOffset]
}

//以下为读取的原始token
private string_literal ::=  STRING_LITERAL
private number_literal ::= NUMBER_LITERAL
private binary_operator ::= BINARY_OPERATOR | MINUS_OPERATOR | ASSIGNMENT_OPERATOR
private unary_operator ::= UNARY_OPERATOR | MINUS_OPERATOR
private assignment_operator ::= ASSIGNMENT_OPERATOR
eol ::= (NEWLINE|COMMENT)+

private at_operator ::= FUNCTION_CALL_OPERATOR
private comma_operator ::= COMMA_OPERATOR
private dot_operator ::= DOT_OPERATOR

// Bracket Operators
private left_parenthesis ::= LEFT_PARENTHESIS
private right_parenthesis ::= RIGHT_PARENTHESIS
private left_square_bracket ::= LEFT_SQUARE_BRACKET
private right_square_bracket ::= RIGHT_SQUARE_BRACKET
private left_curly_bracket ::= LEFT_CURLY_BRACKET
private right_curly_bracket ::= RIGHT_CURLY_BRACKET

//keywords
private fish ::= FISH
private define ::= DEFINE
private end ::= END

private case_of ::= CASEOF
private case ::= CASE
private end_case ::= ENDCASE

private command ::= COMMAND
private end_command ::= ENDCOMMAND

private exit ::= EXIT
private ellipsis ::=  ELLIPSIS

private global ::= GLOBAL
private local ::= LOCAL

private if ::= IF
private then ::= THEN
private elseif ::= ELSEIF | (else if)
private else ::= ELSE
private endif ::= ENDIF

private lock ::= LOCK

private loop ::= LOOP
private foreach ::= FOREACH
private endloop ::= ENDLOOP
private continue ::= CONTINUE
private break ::= BREAK | (exit loop)
private while ::= WHILE
private for ::= FOR

private return ::= RETURN

private section ::= SECTION
private end_section ::= ENDSECTION

private struct ::= STRUCT
private array ::= ARRAY
